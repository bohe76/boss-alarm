# 보스 알리미 시스템 아키텍처 문서 (v2.1 - SSOT & Reconstruction 적용)

## 1. 개요

본 문서는 "보스 알리미" 웹 애플리케이션의 리뉴얼된 시스템 아키텍처를 설명합니다. 이 애플리케이션은 게임 보스 출현 시간을 사용자에게 알리고, 보스 목록을 공유할 수 있는 클라이언트 측 웹 애플리케이션입니다. 기존 단일 화면 구성에서 메뉴 기반의 다중 화면 레이아웃으로 전환하여 사용자 경험을 개선하고 기능별 분리를 강화했습니다. 특히 v2.1에서는 데이터 무결성을 위해 SSOT(Single Source of Truth) 원칙을 도입하고 데이터 재구성(Reconstruction) 전략을 적용했습니다.

## 2. 아키텍처 개요

애플리케이션은 `src/app.js`를 최초 진입점으로 하는 클라이언트 측 단일 페이지 애플리케이션(SPA)입니다. HTML5, CSS3, 바닐라 JavaScript (ES Modules), 웹 음성 API (`window.speechSynthesis`), TinyURL API, **Web Worker API**, **Document Picture-in-Picture API** 등의 기술 스택으로 구성됩니다.

UI는 핵심적으로 **헤더, 내비게이션 메뉴 (사이드바), 메인 콘텐츠 영역, 푸터, 그리고 모바일 뷰를 위한 하단 탭 바**의 5가지 주요 영역으로 나뉘며, JavaScript 코드는 기능별로 `src/` 폴더 내의 여러 ES Modules로 분리되어 각 모듈은 명확한 책임을 가집니다. `src/app.js`는 애플리케이션의 전반적인 초기화, 상태 관리 및 라우팅을 담당하는 최상위 오케스트레이터 역할을 수행합니다.

**백그라운드 알림 처리:** 브라우저의 메인 스레드 부하 나 백그라운드 상태(탭 전환, 최소화)에 영향을 받지 않고 정확한 시간에 알림을 제공하기 위해 **Web Worker (`src/workers/timer-worker.js`)**를 도입했습니다. 타이머 및 알림 조건 체크 로직을 별도 스레드로 분리하여 안정성을 확보했습니다.

메인 콘텐츠 영역은 `src/router.js`와 `src/ui-renderer.js`를 통해 선택된 메뉴 항목에 따라 다른 화면을 동적으로 렌더링합니다. 모바일 뷰에서는 기존 사이드바가 '더보기' 메뉴 오버레이로 재활용됩니다.
초기 로딩 시 사용자 경험 향상을 위해 스켈레톤 UI를 제공하며, `index.html`에 구조가 정의되어 있고 `app.js`에서 제어됩니다.

## 3. 주요 기능

*   **PiP 위젯 (Picture-in-Picture Widget):** 최신 크롬/엣지 브라우저의 Document Picture-in-Picture API를 활용하여, 대시보드의 '다음 보스' 정보(보스 이름, 남은 시간)를 브라우저 밖으로 꺼내어 게임 화면 위에 항상 떠 있는 미니 창으로 제공합니다. (초기 크기: 240x100px)
*   **보스 목록 관리:** 사용자는 텍스트 영역에 `HH:MM 보스이름` 형식으로 보스 출현 시간과 이름을 입력할 수 있습니다. 입력 후 "보스 설정 저장" 버튼을 클릭하여 명시적으로 저장해야 하며, 이때 데이터 파싱, 유효성 검사, 정렬이 수행되어 데이터 무결성을 보장합니다.
*   **시간 기반 알림:** 보스 출현 5분 전, 1분 전, 0분 전에 오디오 및 시각적(로그) 알림이 트리거됩니다.
*   **오디오 알림:** 웹 음성 API (`window.speechSynthesis`)를 활용하여 음성 알림을 제공합니다. **볼륨 슬라이더를 통해 음량 조절 및 음소거 설정이 가능하며, 음소거 해제 시 이전 설정 값으로 복원됩니다.** (기본 음량: 최대)
*   **로깅:** 트리거된 모든 알림 및 시스템 메시지 로그를 표시합니다.
    *   **로그 필터링 (15개 보기):** 사용자는 로그 화면에서 "15개 보기" 토글 버튼을 통해 최근 15개의 로그만 보거나 전체 로그를 볼 수 있으며, 이 설정은 로컬 스토리지에 저장되어 유지됩니다.
*   **공유 가능한 URL:** 현재 텍스트 영역에 입력된 동적 보스 목록을 인코딩하여 다른 사용자와 공유할 수 있는 짧은 URL(TinyURL API를 통해)을 생성합니다. (개인 설정인 고정 알림 목록은 포함되지 않습니다.)
*   **젠/광 계산기:** 보스 리젠 시간을 계산하는 유틸리티 기능을 제공합니다.
*   **도움말 및 FAQ:** 탭 기반 인터페이스를 통해 애플리케이션 기능 사용법을 안내하는 '도움말'과 자주 묻는 질문에 대한 답변을 제공하는 'FAQ' 섹션을 제공합니다.
*   **고정 알림 (Fixed Alarms):** 사용자가 설정한 요일에 따라 반복되는 알림을 제공합니다. 모달을 통해 추가/편집할 수 있으며, 활성/비활성 상태를 개별적으로 관리합니다.
*   **카카오톡 인앱 브라우저 회피:** 카카오톡 인앱 브라우저에서 발생하는 기능 제한 및 오작동 문제를 해결하기 위해, 인앱 브라우저 환경을 감지하고 사용자에게 외부 브라우저(Android는 자동 리디렉션, iOS는 수동 전환 안내)로 이동하도록 유도합니다.

## 4. 기술 스택 상세

*   **HTML5 / CSS3:** 웹 표준 마크업 및 스타일링. CSS는 `src/styles/style.css` 외부 파일로 링크됩니다.
*   **정적 자원:** 이미지 파일 등은 `src/assets/images` 경로에 관리됩니다.
*   **바닐라 JavaScript (ES Modules):** 프레임워크 없이 순수 JavaScript를 사용하여 모듈화된 형태로 개발되었습니다. `src/` 폴더 내에서 기능별로 분리된 모듈들을 `import`하여 사용합니다. 특히 `utils.js`에는 `calculateNextOccurrence`와 같은 핵심 시간 계산 유틸리티가 포함되어 있습니다.
*   **설정 및 데이터 파일:** `data/` 폴더에 `boss_lists.json`, `faq_guide.json`, `feature_guide.json`, `version_history.json`과 같은 설정 및 데이터 파일을 관리합니다.
    *   **데이터 관리 (SSOT & Reconstruction):**
        *   `BossDataManager`를 데이터의 유일한 진실 공급원(SSOT)으로 사용합니다.
        *   모든 데이터 변경(입력, 수정, 업데이트) 시 **Reconstruction(재구성) 전략**을 사용하여 데이터를 날짜순/시간순으로 정렬하고, 날짜 마커를 적절한 위치에 자동으로 삽입하여 저장합니다. 이를 통해 날짜 꼬임이나 데이터 중복 문제를 원천적으로 방지합니다.
        *   보스 객체는 고유 ID를 통해 식별되며, 이름 중복 시에도 안전하게 업데이트됩니다. 특히 고정 알림은 시간, 이름 외에 요일 정보(days)를 포함하며, 모든 시간 관련 계산은 사용자 로컬 시간대 기준으로 처리됩니다.*   **Web Speech API (`window.speechSynthesis`):** 음성 알림 기능을 구현하는 데 사용됩니다.
*   **TinyURL API:** 공유 가능한 짧은 URL을 생성하는 데 사용됩니다.
*   **비동기 처리:** `fetch` API 및 `async/await` 문법을 활용하여 TinyURL API 호출, JSON 파일 로드, 클립보드 작업 등 비동기 작업을 효율적으로 처리합니다.
*   **Local Storage:** `LocalStorageManager`를 통해 사용자 설정(고정 알림, 음소거 상태, 사이드바 확장 상태 등) 및 사용자 지정 데이터(광 계산기 기록 등)를 브라우저에 영구적으로 저장합니다.

## 5. 애플리케이션 빌드 및 실행

이 프로젝트는 클라이언트 측 웹 애플리케이션으로, HTML, CSS, JavaScript 모듈로 구성됩니다. 특별한 빌드 단계나 서버 측 구성 요소는 필요하지 않습니다.

**애플리케이션 실행 방법:**
1.  `index.html` 파일을 최신 웹 브라우저(예: Chrome, Firefox, Edge)에서 엽니다.
2.  **참고:** `file://` 프로토콜로 `index.html`을 직접 열 경우, 일부 브라우저에서 보안상의 이유로 `fetch` 요청(예: TinyURL API 호출, 도움말 문서 로드)이 CORS 오류로 실패할 수 있습니다. 모든 기능을 정상적으로 사용하려면, 로컬 웹 서버(예: VS Code Live Server 확장)를 사용하여 애플리케이션을 실행하는 것을 권장합니다.

## 6. 테스트 환경

코드 품질을 보장하고, 회귀를 방지하며, 안정적인 리팩토링 프로세스를 촉진하기 위해 이 프로젝트는 테스트 프레임워크로 **Vitest**를 도입했습니다.

*   **테스트 디렉터리 및 구조:**
    *   모든 유닛 테스트 파일은 프로젝트 루트의 `test/` 디렉터리에 위치합니다. 이 디렉터리 내의 테스트 파일은 `*.test.js` 명명 규칙을 따릅니다.
    *   복잡도가 높은 모듈의 테스트는 기능별 관심사에 따라 여러 파일로 분리하여 관리합니다. (예: `boss-scheduler` 모듈은 `boss-scheduler.init.test.js`, `boss-scheduler.apply.test.js`, `boss-scheduler.ui.test.js` 등으로 분리하여 초기화, 로직 적용, UI 상호작용 등 특정 기능에 집중합니다.)
*   **테스트 범위:** 현재 다음 핵심 모듈에 대한 유닛 테스트가 포함되어 있습니다.
    *   `src/utils.js`: 범용 유틸리티 함수
    *   `src/calculator.js`: 젠 계산기 로직
    *   `src/boss-parser.js`: 보스 목록 파싱 및 정렬 로직
    *   `src/crazy-calculator.js`: 광 계산기 로직
    *   `src/custom-list-manager.js`: 사용자 지정 보스 목록 관리 로직
    *   `src/screens/boss-scheduler.js`: 보스 스케줄러 화면의 핵심 로직 및 UI 상호작용
    *   `src/data-managers.js` & `src/alarm-scheduler.js`: 보스 정렬 및 알림 체크 로직 (날짜 포함 정렬 검증)
*   **프레임워크:** [Vitest](https://vitest.dev/) - Vite 프로젝트와 호환되는 최신의 빠르고 기능이 풍부한 테스트 프레임워크이지만, ES 모듈을 사용하는 바닐라 JavaScript 프로젝트에서도 훌륭하게 작동합니다.
*   **환경:** [JSDOM](https://jsdom.github.io/) - 테스트 환경은 Node.js 환경 내에서 가상 DOM 구현을 제공하는 JSDOM을 사용하도록 구성되어 있습니다. 이를 통해 전체 브라우저 인스턴스를 실행할 필요 없이 DOM 조작 및 브라우저와 유사한 동작을 테스트할 수 있습니다.
*   **주요 테스트 방법론:**
    *   **Mocking 전략:**
        *   `vi.mock('module-path', () => ({ ... }))`를 사용하여 모듈 전체를 Mocking하거나 특정 변수를 하드 코딩합니다.
        *   `vi.spyOn(module, 'function').mockImplementation(() => ...)`을 사용하여 모듈 내 특정 함수의 호출을 가로채고 Mocking 또는 스파이합니다.
        *   `EventBus`와 같이 이벤트 기반 통신을 사용하는 모듈의 경우, `vi.mock` 내에서 `listeners` 객체를 관리하고 `emit` 함수가 등록된 콜백들을 실제로 실행하도록 구현하여 실제 이벤트 흐름을 시뮬레이션합니다.
    *   **DOM 상태 직접 제어:**
        *   JSDOM 환경의 비일관적인 이벤트 처리를 보완하기 위해, `beforeEach`에서 `DOM.innerHTML = `...``와 같이 필요한 DOM 구조를 직접 명시적으로 구성합니다.
        *   `input.dataset.calculatedDate`와 같은 중요 메타데이터는 Mocking된 함수의 반환값을 사용하여 `input.dispatchEvent`를 통해 정확히 설정되도록 합니다.
        *   `src` 코드에서 참조하는 모든 필수 DOM 요소(예: `DOM.bossListInput`)는 테스트의 `DOM` Mock 객체에 명시적으로 추가하여 `undefined` 오류를 방지합니다.
    *   **데이터 Mocking (JSON 하드 코딩):**
        *   `src/default-boss-list.js`와 같이 외부 JSON 데이터를 로드하는 모듈은 `vi.mock`을 통해 테스트 코드 내에서 **하드 코딩된 JavaScript 객체 리터럴**(`DEFAULT_BOSS_LIST_KOR: [...]`)을 반환하도록 설정합니다. 이를 통해 파일 시스템 의존성을 제거하고 테스트의 안정성과 예측 가능성을 높입니다.
*   **구성:**
    *   테스트 설정은 `vitest.config.js`에 정의되어 있습니다.
    *   `globals`가 활성화되어(`globals: true`) 일반적인 테스트 함수(`describe`, `it`, `expect`, `vi`)를 명시적인 가져오기 없이 모든 테스트 파일에서 사용할 수 있습니다.
*   **시간 Mocking 일관성:** 테스트 시에는 일관된 시간 Mocking을 위해 로컬 시간대를 기준으로 `vi.setSystemTime`을 사용하고 `Date` 객체를 생성하여 테스트 환경과 애플리케이션 로직 간의 시간대 불일치를 방지합니다. (Issue-014 해결)
*   **실행:**
    *   테스트는 `package.json`에 정의된 `npm test` 스크립트를 사용하여 실행할 수 있습니다.
    *   **참고:** 만약 PowerShell 실행 정책(Execution Policy) 문제로 `npm test` 명령이 실패하는 경우, 다음 명령어를 대신 사용할 수 있습니다.
        ```shell
        node ./node_modules/vitest/dist/cli.js run
        ```
    *   이는 애플리케이션의 로직을 검증하고 새로운 변경으로 인한 의도하지 않은 부작용을 방지하는 표준화된 방법을 제공합니다.

## 7. 프로젝트 의존성 관리

프로젝트의 의존성은 Node.js 패키지 매니저인 npm을 통해 관리됩니다. `package-lock.json` 파일은 프로젝트의 모든 직접 및 전이 의존성에 대한 정확한 버전 정보를 기록합니다. 이는 모든 개발 환경에서 일관된 의존성 설치를 보장하고, 의존성 업데이트로 인한 잠재적인 문제를 방지하는 데 필수적입니다.

*   **`package.json`**: 프로젝트의 직접적인 의존성(dependencies)과 개발 의존성(devDependencies)을 명시합니다.
*   **`package-lock.json`**: `npm install` 명령 실행 시 생성/업데이트되며, 모든 패키지의 정확한 버전, 출처, 무결성 정보를 기록합니다. 이 파일은 `git`에 커밋되어 팀 전체의 일관된 개발 환경을 유지하는 데 사용됩니다.

## 8. 모듈별 상세 설명
애플리케이션을 구성하는 각 모듈의 역할과 주요 기능에 대한 자세한 내용은 [모듈 상세 문서](system_module_details_v2.md)를 참조하십시오.

## 9. 모듈 간 의존성
애플리케이션을 구성하는 모듈 간의 상세한 의존성 관계는 [모듈 의존성 문서](system_module_dependencies_v2.md)를 참조하십시오.

## 10. 데이터 흐름
애플리케이션의 주요 데이터 흐름 및 각 모듈 간의 상호작용에 대한 상세 내용은 [데이터 흐름 문서](system_data_flow_v2.md)를 참조하십시오.

## 11. 주요 시간 입력 규칙 (Key Time Input Rules)

애플리케이션의 각 기능별 시간 입력 방식은 일관성 유지를 위해 다음과 같이 정의됩니다.

**1. 보스 관리 (텍스트 에어리어)**
*   **의미:** 절대적인 출현 시각 (Time of Day)
*   **허용 형식:** `HH:MM` 또는 `HH:MM:SS` (예: `23:01`, `23:01:15`). 숫자만 입력 시 `HHMM` 형식으로도 인식합니다.

**2. 보스 스케줄러 (남은 시간)**
*   **의미:** '남은 시간' (Remaining Time)
*   **허용 형식:** `HH:MM:SS` 또는 `HH:MM` (예: `01:10:30`, `01:10`). **시간과 분**으로 해석됩니다.

**3. 젠 계산기 (남은 시간)**
*   **의미:** '남은 시간' (Remaining Time)
*   **허용 형식:** `MM:SS` (예: `10:30`). 숫자만 입력 시 `MMSS` 형식으로 간주합니다. (예: `1030` -> 10분 30초, `130` -> 1분 30초, `45` -> 45초). **분과 초**로 해석됩니다.

**4. 고정 알림 (시간 설정)**
*   **의미:** 절대적인 알림 시각 (Time of Day)
*   **허용 형식:** `HH:MM` 또는 `HHMM` (예: `19:30`, `1930`). **초(second) 입력은 허용되지 않습니다.**
