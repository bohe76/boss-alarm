# 보스 알리미 시스템 아키텍처 문서 (v2.6 - 자가 복구 & 격리 저장소 적용)

## 1. 개요

본 문서는 "보스 알리미" 웹 애플리케이션의 리뉴얼된 시스템 아키텍처를 설명합니다. 이 애플리케이션은 게임 보스 출현 시간을 사용자에게 알리고, 보스 목록을 공유할 수 있는 클라이언트 측 웹 애플리케이션입니다. 기존 단일 화면 구성에서 메뉴 기반의 다중 화면 레이아웃으로 전환하여 사용자 경험을 개선하고 기능별 분리를 강화했습니다. 특히 v2.6에서는 데이터 오염 시 앱 멈춤을 방지하는 **지능형 자가 복구 엔진**과 각 게임별 입력 데이터를 안전하게 보호하는 **독립 작업 공간(Workspace Isolation)** 아키텍처를 적용했습니다.

## 2. 아키텍처 개요

애플리케이션은 `src/app.js`를 최초 진입점으로 하는 클라이언트 측 단일 페이지 애플리케이션(SPA)입니다. HTML5, CSS3, 바닐라 JavaScript (ES Modules), 웹 음성 API (`window.speechSynthesis`), TinyURL API, **Web Worker API**, **Document Picture-in-Picture API** 등의 기술 스택으로 구성됩니다.

UI는 핵심적으로 **헤더, 내비게이션 메뉴 (사이드바), 메인 콘텐츠 영역, 푸터, 그리고 모바일 뷰를 위한 하단 탭 바**의 5가지 주요 영역으로 나뉘며, JavaScript 코드는 기능별로 `src/` 폴더 내의 여러 ES Modules로 분리되어 각 모듈은 명확한 책임을 가집니다. `src/app.js`는 애플리케이션의 전반적인 초기화, 상태 관리 및 라우팅을 담당하는 최상위 오케스트레이터 역할을 수행합니다.

**지능형 네비게이션 UX (v2.2):**
*   **PC 오버레이 사이드바**: 레이아웃 흔들림(Layout Shift)을 방지하기 위해 사이드바 너비를 고정(Icon Rail)하고, 마우스 호버 시 본문 위로 메뉴 명칭이 부드럽게 펼쳐지는 오버레이 방식을 채택했습니다. 햄버거 버튼을 제거하여 인지 부하를 줄였습니다.
*   **모바일 하단 탭 바 확장**: 기존 4개 메뉴에서 '보스 스케줄러'를 추가한 5개 메뉴 체계(대시보드, 시간표, 스케줄러, 계산기, 공유)로 확장하여 핵심 기능에 대한 접근성을 극대화했습니다.

**백그라운드 알림 처리:** 브라우저의 메인 스레드 부하 나 백그라운드 상태(탭 전환, 최소화)에 영향을 받지 않고 정확한 시간에 알림을 제공하기 위해 **Web Worker (`src/workers/timer-worker.js`)**를 도입했습니다. 타이머 및 알림 조건 체크 로직을 별도 스레드로 분리하여 안정성을 확보했습니다.

메인 콘텐츠 영역은 `src/router.js`와 `src/ui-renderer.js`를 통해 선택된 메뉴 항목에 따라 다른 화면을 동적으로 렌더링합니다. 모바일 뷰에서는 기존 사이드바가 '더보기' 메뉴 오버레이로 재활용됩니다.
**차세대 레이아웃 매칭 스켈레톤 UI (v2.3):** 대시보드의 비대칭 2단 컬럼 레이아웃과 1:1로 대응하는 정밀한 스켈레톤 구조를 `#dashboard-skeleton`에 직결했습니다. 로딩 시 Shimmer 애니메이션과 Fade-in 효과를 적용하여 시각적 흔들림(CLS)을 원천 차단하고, 실제 콘텐츠로의 전환을 자연스럽게 유도합니다.

## 3. 주요 기능

*   **PiP 위젯 (Picture-in-Picture Widget):** 최신 크롬/엣지 브라우저의 Document Picture-in-Picture API를 활용하여, 대시보드의 '다음 보스' 정보(보스 이름, 남은 시간)를 브라우저 밖으로 꺼내어 게임 화면 위에 항상 떠 있는 미니 창으로 제공합니다. (초기 크기: 240x100px)
*   **보스 시간표:** '보스 시간표' 화면에 **뷰 모드**와 **편집 모드**를 제공합니다.
    *   **편집 모드:** 사용자는 텍스트 영역에 `HH:MM 보스이름` 형식으로 보스 출현 시간과 이름을 입력할 수 있습니다. 입력 후 "보스 시간 업데이트" 버튼을 클릭하여 명시적으로 저장해야 하며, 이때 데이터 파싱, 유효성 검사, 정렬이 수행되어 데이터 무결성을 보장합니다.
    *   **뷰 모드:** 보스 목록을 **카드 리스트** 또는 **테이블(표)** 형태로 선택하여 볼 수 있습니다.
        *   **카드 모드:** 날짜별로 그룹화된 직관적인 카드 형태로 보스 정보를 표시합니다.
        *   **테이블 모드:** 세련된 브라운 테마의 표 형식으로 많은 정보를 한눈에 파악하기 용이합니다.
        *   '다음 보스' 필터 기능을 통해 현재 시간 이후의 보스만 볼 수 있으며, 마지막으로 사용한 보기 모드는 로컬 스토리지에 유지됩니다.
*   **시간표 내보내기 및 실시간 프리뷰**: 텍스트 복사 및 이미지 저장 기능을 제공하며, 사용자 경험을 위해 다음 기술을 적용했습니다.
    *   **WYSIWYG 프리뷰**: 내보내기 옵션 변경 시 배경 UI가 즉시 동기화되어 결과물을 미리 확인 가능.
    *   **고해상도 이미지 캡처**: `html2canvas` 라이브러리를 통해 브라우저 화면을 PNG 이미지로 변환.
    *   **상태 자동 복원**: 내보내기 완료 후 모달 오픈 전의 원래 상태(화면, 필터 등)로 자동 복구.
    *   **연타 방지 보안 가드**: 이미지 생성 중 버튼을 잠금 처리하여 중복 다운로드 방지.
    *   일반 길드원들이 보스 목록을 확인하기에 용이합니다.
*   **시간 기반 알림:** 보스 출현 5분 전, 1분 전, 0분 전에 오디오 및 시각적(로그) 알림이 트리거됩니다.
*   **오디오 알림:** 웹 음성 API (`window.speechSynthesis`)를 활용하여 음성 알림을 제공합니다. **볼륨 슬라이더를 통해 음량 조절 및 음소거 설정이 가능하며, 음소거 해제 시 이전 설정 값으로 복원됩니다.** (기본 음량: 최대)
*   **로깅:** 트리거된 모든 알림 및 시스템 메시지 로그를 표시합니다.
    *   **로그 필터링 (15개 보기):** 사용자는 로그 화면에서 "15개 보기" 토글 버튼을 통해 최근 15개의 로그만 보거나 전체 로그를 볼 수 있으며, 이 설정은 로컬 스토리지에 저장되어 유지됩니다.
*   **공유 가능한 URL:** 현재 텍스트 영역에 입력된 동적 보스 목록을 인코딩하여 다른 사용자와 공유할 수 있는 짧은 URL(TinyURL API를 통해)을 생성합니다. (개인 설정인 고정 알림 목록은 포함되지 않습니다.)
*   **젠/광 계산기:** 보스 리젠 시간을 계산하는 유틸리티 기능을 제공합니다.
*   **도움말 및 FAQ:** 탭 기반 인터페이스를 통해 애플리케이션 기능 사용법을 안내하는 '도움말'과 자주 묻는 질문에 대한 답변을 제공하는 'FAQ' 섹션을 제공합니다.
*   **고정 알림 (Fixed Alarms):** 사용자가 설정한 요일에 따라 반복되는 알림을 제공합니다. 모달을 통해 추가/편집할 수 있으며, 활성/비활성 상태를 개별적으로 관리합니다.
*   **버전 업데이트 안내 모달 (Update Notification):** 대규모 기능 업데이트 시 앱 시작 단계에서 변경 사항을 안내합니다. 
    *   **지능형 노출 제어**: 로컬 스토리지를 통해 버전별 최초 1회 노출을 보장하며, 사용자가 '다시 보지 않기' 클릭 시 해당 버전에 대한 알림을 영구히 종료합니다.
    *   **심플 액션 바**: '자세히 보기'와 '다시 보지 않기' 두 가지 핵심 클릭 요소를 하단 바 스타일로 제공하여 시각적 인지 부하를 최소화했습니다.
    *   **데이터 주도 관리 (Data-driven)**: 공지 내용(인사말, 요약 목록)을 외부 JSON(`update-notice.json`)으로 분리하여 로직 수정 없이 콘텐츠만 유연하게 변경할 수 있는 구조를 갖추었습니다.
*   **카카오톡 인앱 브라우저 회피:** 카카오톡 인앱 브라우저에서 발생하는 기능 제한 및 오작동 문제를 해결하기 위해, 인앱 브라우저 환경을 감지하고 사용자에게 외부 브라우저(Android는 자동 리디렉션, iOS는 수동 전환 안내)로 이동하도록 유도합니다.

## 4. 기술 스택 상세

*   **HTML5 / CSS3:** 웹 표준 마크업 및 스타일링. CSS는 `src/styles/style.css`를 진입점으로 하여 `layout.css`, `components.css`, `screens.css`로 모듈화되어 관리됩니다.
*   **정적 자원:** 이미지 파일 등은 `src/assets/images` 경로에 관리됩니다.
*   **바닐라 JavaScript (ES Modules):** 프레임워크 없이 순수 JavaScript를 사용하여 모듈화된 형태로 개발되었습니다. `src/` 폴더 내에서 기능별로 분리된 모듈들을 `import`하여 사용합니다. 특히 `utils.js`에는 `calculateNextOccurrence`와 같은 핵심 시간 계산 유틸리티가 포함되어 있습니다.
*   **설정 및 데이터 파일:** `src/data/` 폴더에 `boss-presets.json`, `initial-default.json`, `update-notice.json`, `faq_guide.json`, `feature_guide.json`, `version_history.json`과 같은 설정 및 데이터 파일을 관리합니다.
    *   **JS → JSON 데이터 관리 체계 전환:** 기존에 JavaScript 코드 내에 하드코딩되어 있던 보스 데이터 및 공지 사항 등을 외부 JSON 파일로 분리하였습니다. 이를 통해 데이터 수정 시 코드 변경 없이 JSON 파일만 수정하면 되며, 유지보수성과 확장성이 향상되었습니다.
    *   **데이터 관리 (SSOT & Draft 패턴):**
        *   보스 메타데이터(젠 주기 등)는 `boss-presets.json`에서 비동기로 로드하며, `BossDataManager`에 주입하여 효율적인 실시간 조회를 지원합니다.
        *   **Main SSOT와 Draft 패턴:** `BossDataManager`는 Main SSOT(확정 데이터)와 Draft(임시 편집 데이터)를 분리하여 관리합니다. SSOT 변경 시 Draft가 즉시 동기화되며, 모두 localStorage에 영구 저장됩니다.
        *   **SSOT 데이터 구성 요소 (Boss Object):** 데이터의 일관성을 위해 모든 보스 객체는 다음 필드를 필수적으로 포함합니다.
            *   `id`: `boss-[이름]-[타임스탬프]` 형식의 **유일 식별자(UID)**. 인스턴스별 독립성 보장.
            *   `name`: 보스 이름 (프리셋 매칭 키).
            *   `scheduledDate`: **데이터의 진실(Truth)**. 실제 연산과 알림의 기준이 되는 JS Date 객체.
            *   `time / timeFormat`: 입력된 시간 문자열과 포멧(`hm`/`hms`)을 보존하여 UI 출력 일관성 유지.
            *   `memo`: 해당 타임슬롯 고유의 비고 내용.
            *   `type`: 아이템 유형 (`boss` 고정).
        *   **인스턴스 개별 관리 및 사용자 의도 보존 (User Intent Preservation):** 
            *   동일 보스라도 각 시간대는 독립적인 생명력을 가진 데이터로 취급됩니다. 
            *   텍스트 모드 등에서 사용자가 직접 입력/수정한 데이터는 '고정 앵커'로 잠금 처리되어, 시스템의 자동 생성 로직에 의해 덮어씌워지지 않고 철저히 보존됩니다.
        *   **시간 정밀도 유지 및 Time Drift 방지:** 모든 시간 연산은 SSOT의 `scheduledDate`를 절대적인 기준으로 삼습니다. UI 렌더링 시 분 단위 남은 시간에서 역계산하는 방식 대신, SSOT의 정밀한 시점(Date 객체)을 직접 출력하여 누적 오차를 차단합니다.
        *   **지능형 UI 동기화 (Intelligent Mapping):** 간편 입력 모드 UI는 현재 시각 기준 **가장 가까운 미래의 인스턴스**를 실시간으로 추적하여 비고(memo) 및 상태를 동기화합니다. 이를 통해 보스당 하나의 입력창만으로도 각 시간별 고유 정보를 정확하게 관리할 수 있습니다.
        *   **시간 역전 및 음수 시간 처리:** `boss-parser.js`는 시간 역전 감지를 통해 날짜를 자동 롤오버하며, `calculator.js`는 음수 남은 시간 입력을 지원하여 과거의 정확한 젠 시점을 계산할 수 있습니다.
        *   **침공 보스 필터링 및 날짜 무결성**: 
            *   프리셋 메타데이터의 `isInvasion` 플래그를 참조하여, 당일이 아닌 침공 보스는 일정 확장(`_expandAndReconstruct`) 과정에서 자동으로 제외하여 불필요한 알림을 방지하고 정합성을 유지합니다.
            *   텍스트 모드 파싱(`boss-parser.js`) 시 첫 줄에 날짜(`MM.DD`) 포함을 의무화하여, 다가오는 일정의 기준 시점이 명확히 정의되도록 강제합니다.
        *   **하이브리드 입력 최적화 (Hybrid Input UI)**: 
            *   보스 스케줄러 간편 모드에서 기기별 최적화된 레이아웃을 제공하며, 명시적 구분자(`#`, `@`)를 사용하여 비고와 젠 주기를 정밀하게 관리합니다.
            *   유효성 검사는 사용자 입력을 방해하지 않도록 '보스 시간 업데이트' 버튼 클릭 시점에만 수행하는 지연 검증(Deferred Validation) 정책을 적용합니다.
        *   데이터 로딩 실패 시 사용자에게 알림(`alert`)을 제공하고 빈 스케줄로 폴백(Fallback)하여 앱의 안정성을 보장합니다.
        *   **지능형 SSOT 자동 업데이트 엔진 (v2.5)**:
            *   **자율 롤링 윈도우**: 자정(00:00) 기준점으로 매일 1회 스케줄을 재구성하여 "오늘+내일"의 48시간 데이터를 항상 유지함.
            *   **Smart-Dirty 검사**: 메인 SSOT와 임시 Draft의 JSON 비교를 통해 사용자 편집 중 여부를 1ms 내에 판단.
            *   **사용자 편집권 보호**: 수정 사항이 없을 경우 자동 업데이트를 수행하며, 수정 중일 경우 날짜 안내 팝업을 통해 사용자 선택권(갱신/유지)을 보장함.
            *   **Background Integrity**: 사용자가 수동 업데이트를 취소하더라도 알람 엔진용 메인 SSOT는 최신화하여 서비스 연속성 보장.
        *   **지능형 자가 복구 및 무결성 보호 (v2.6)**:
            *   **Integrity Screening**: URL 및 로컬 스토리지 데이터 로드 시 현재 시스템 정의(프리셋/커스텀)와 대조하여 '유령 보스' 존재 여부를 즉시 검증함.
            *   **Safe Fallback**: 데이터 오염 감지 시 사용자에게 안내 후 즉시 깨끗한 샘플 데이터로 복구하여 무한 로딩 및 런타임 에러를 원천 차단함.
            *   **Workspace Isolation**: 각 보스 목록(게임)별로 독립적인 저장 키를 사용하여, 여러 게임을 번갈아 작업해도 사용자의 입력 정보가 서로 섞이지 않고 안전하게 보존됨.
        *   모든 데이터 변경(입력, 수정, 업데이트) 시 **Reconstruction(재구성) 전략**을 사용하여 데이터를 날짜순/시간순으로 정렬하고, 일관된 날짜 마커를 삽입합니다.
*   **Web Speech API (`window.speechSynthesis`):** 음성 알림 기능을 구현하는 데 사용됩니다.
*   **TinyURL API:** 공유 가능한 짧은 URL을 생성하는 데 사용됩니다.
*   **비동기 처리:** `fetch` API 및 `async/await` 문법을 활용하여 TinyURL API 호출, JSON 파일 로드, 클립보드 작업 등 비동기 작업을 효율적으로 처리합니다.
*   **Local Storage:** `LocalStorageManager`를 통해 사용자 설정(고정 알림, 음소거 상태, 사이드바 확장 상태 등) 및 사용자 지정 데이터(광 계산기 기록 등)를 브라우저에 영구적으로 저장합니다.

## 5. 애플리케이션 빌드 및 실행

이 프로젝트는 클라이언트 측 웹 애플리케이션으로, HTML, CSS, JavaScript 모듈로 구성됩니다. 특별한 빌드 단계나 서버 측 구성 요소는 필요하지 않습니다.

**애플리케이션 실행 방법:**
1.  `index.html` 파일을 최신 웹 브라우저(예: Chrome, Firefox, Edge)에서 엽니다.
2.  **참고:** `file://` 프로토콜로 `index.html`을 직접 열 경우, 일부 브라우저에서 보안상의 이유로 `fetch` 요청(예: TinyURL API 호출, 도움말 문서 로드)이 CORS 오류로 실패할 수 있습니다. 모든 기능을 정상적으로 사용하려면, 로컬 웹 서버(예: VS Code Live Server 확장)를 사용하여 애플리케이션을 실행하는 것을 권장합니다.

## 6. 테스트 환경

코드 품질을 보장하고, 회귀를 방지하며, 안정적인 리팩토링 프로세스를 촉진하기 위해 이 프로젝트는 테스트 프레임워크로 **Vitest**를 도입했습니다.

*   **테스트 디렉터리 및 구조:**
    *   모든 유닛 테스트 파일은 프로젝트 루트의 `test/` 디렉터리에 위치합니다. 이 디렉터리 내의 테스트 파일은 `*.test.js` 명명 규칙을 따릅니다.
    *   복잡도가 높은 모듈의 테스트는 기능별 관심사에 따라 여러 파일로 분리하여 관리합니다. (예: `boss-scheduler` 모듈은 `boss-scheduler.init.test.js`, `boss-scheduler.apply.test.js`, `boss-scheduler.ui.test.js` 등으로 분리하여 초기화, 로직 적용, UI 상호작용 등 특정 기능에 집중합니다.)
*   **테스트 범위:** 현재 다음 핵심 모듈에 대한 유닛 테스트가 포함되어 있습니다.
    *   `src/utils.js`: 범용 유틸리티 함수
    *   `src/calculator.js`: 젠 계산기 로직
    *   `src/boss-parser.js`: 보스 목록 파싱 및 정렬 로직
    *   `src/crazy-calculator.js`: 광 계산기 로직
    *   `src/custom-list-manager.js`: 사용자 지정 보스 목록 관리 로직
    *   `src/screens/boss-scheduler.js`: 보스 스케줄러 화면의 핵심 로직 및 UI 상호작용
    *   `src/data-managers.js` & `src/alarm-scheduler.js`: 보스 정렬 및 알림 체크 로직 (날짜 포함 정렬 검증)
*   **프레임워크:** [Vitest](https://vitest.dev/) - Vite 프로젝트와 호환되는 최신의 빠르고 기능이 풍부한 테스트 프레임워크이지만, ES 모듈을 사용하는 바닐라 JavaScript 프로젝트에서도 훌륭하게 작동합니다.
*   **환경:** [JSDOM](https://jsdom.github.io/) - 테스트 환경은 Node.js 환경 내에서 가상 DOM 구현을 제공하는 JSDOM을 사용하도록 구성되어 있습니다. 이를 통해 전체 브라우저 인스턴스를 실행할 필요 없이 DOM 조작 및 브라우저와 유사한 동작을 테스트할 수 있습니다.
*   **주요 테스트 방법론:**
    *   **Mocking 전략:**
        *   `vi.mock('module-path', () => ({ ... }))`를 사용하여 모듈 전체를 Mocking하거나 특정 변수를 하드 코딩합니다.
        *   `vi.spyOn(module, 'function').mockImplementation(() => ...)`을 사용하여 모듈 내 특정 함수의 호출을 가로채고 Mocking 또는 스파이합니다.
        *   `EventBus`와 같이 이벤트 기반 통신을 사용하는 모듈의 경우, `vi.mock` 내에서 `listeners` 객체를 관리하고 `emit` 함수가 등록된 콜백들을 실제로 실행하도록 구현하여 실제 이벤트 흐름을 시뮬레이션합니다.
    *   **DOM 상태 직접 제어:**
        *   JSDOM 환경의 비일관적인 이벤트 처리를 보완하기 위해, `beforeEach`에서 `DOM.innerHTML = `...``와 같이 필요한 DOM 구조를 직접 명시적으로 구성합니다.
        *   `input.dataset.calculatedDate`와 같은 중요 메타데이터는 Mocking된 함수의 반환값을 사용하여 `input.dispatchEvent`를 통해 정확히 설정되도록 합니다.
        *   `src` 코드에서 참조하는 모든 필수 DOM 요소(예: `DOM.bossListInput`)는 테스트의 `DOM` Mock 객체에 명시적으로 추가하여 `undefined` 오류를 방지합니다.
    *   **데이터 Mocking:**
        *   `src/boss-scheduler-data.js` 등 외부 JSON 데이터를 비동기로 로드하는 모듈은 `vi.mock`을 통해 테스트 코드 내에서 **하드 코딩된 데이터**를 반환하도록 하거나, `fetch`를 모킹하여 처리합니다. 이를 통해 파일 시스템 의존성을 제거하고 테스트의 안정성과 예측 가능성을 높입니다.
*   **구성:**
    *   테스트 설정은 `vitest.config.js`에 정의되어 있습니다.
    *   `globals`가 활성화되어(`globals: true`) 일반적인 테스트 함수(`describe`, `it`, `expect`, `vi`)를 명시적인 가져오기 없이 모든 테스트 파일에서 사용할 수 있습니다.
*   **시간 Mocking 일관성:** 테스트 시에는 일관된 시간 Mocking을 위해 로컬 시간대를 기준으로 `vi.setSystemTime`을 사용하고 `Date` 객체를 생성하여 테스트 환경과 애플리케이션 로직 간의 시간대 불일치를 방지합니다. (Issue-014 해결)
*   **실행:**
    *   테스트는 `package.json`에 정의된 `npm test` 스크립트를 사용하여 실행할 수 있습니다.
    *   **참고:** 만약 PowerShell 실행 정책(Execution Policy) 문제로 `npm test` 명령이 실패하는 경우, 다음 명령어를 대신 사용할 수 있습니다.
        ```shell
        node ./node_modules/vitest/dist/cli.js run
        ```
    *   이는 애플리케이션의 로직을 검증하고 새로운 변경으로 인한 의도하지 않은 부작용을 방지하는 표준화된 방법을 제공합니다.

## 7. 프로젝트 의존성 관리

프로젝트의 의존성은 Node.js 패키지 매니저인 npm을 통해 관리됩니다. `package-lock.json` 파일은 프로젝트의 모든 직접 및 전이 의존성에 대한 정확한 버전 정보를 기록합니다. 이는 모든 개발 환경에서 일관된 의존성 설치를 보장하고, 의존성 업데이트로 인한 잠재적인 문제를 방지하는 데 필수적입니다.

*   **`package.json`**: 프로젝트의 직접적인 의존성(dependencies)과 개발 의존성(devDependencies)을 명시합니다.
*   **`package-lock.json`**: `npm install` 명령 실행 시 생성/업데이트되며, 모든 패키지의 정확한 버전, 출처, 무결성 정보를 기록합니다. 이 파일은 `git`에 커밋되어 팀 전체의 일관된 개발 환경을 유지하는 데 사용됩니다.

## 8. 모듈별 상세 설명
애플리케이션을 구성하는 각 모듈의 역할과 주요 기능에 대한 자세한 내용은 [모듈 상세 문서](system_module_details_v2.md)를 참조하십시오.

## 9. 모듈 간 의존성
애플리케이션을 구성하는 모듈 간의 상세한 의존성 관계는 [모듈 의존성 문서](system_module_dependencies_v2.md)를 참조하십시오.

## 10. 데이터 흐름
애플리케이션의 주요 데이터 흐름 및 각 모듈 간의 상호작용에 대한 상세 내용은 [데이터 흐름 문서](system_data_flow_v2.md)를 참조하십시오.

## 11. 주요 시간 입력 규칙 (Key Time Input Rules)

애플리케이션의 각 기능별 시간 입력 방식은 일관성 유지를 위해 다음과 같이 정의됩니다.

**1. 보스 관리 (텍스트 에어리어)**
*   **의미:** 절대적인 출현 시각 (Time of Day)
*   **허용 형식:** `HH:MM` 또는 `HH:MM:SS` (예: `23:01`, `23:01:15`). 숫자만 입력 시 `HHMM` 형식으로도 인식합니다.

**2. 보스 스케줄러 (남은 시간)**
*   **의미:** '남은 시간' (Remaining Time)
*   **허용 형식:** `HH:MM:SS` 또는 `HH:MM` (예: `01:10:30`, `01:10`). **시간과 분**으로 해석됩니다.

**3. 젠 계산기 (남은 시간)**
*   **의미:** '남은 시간' (Remaining Time)
*   **허용 형식:** `MM:SS` (예: `10:30`). 숫자만 입력 시 `MMSS` 형식으로 간주합니다. (예: `1030` -> 10분 30초, `130` -> 1분 30초, `45` -> 45초). **분과 초**로 해석됩니다.

**4. 고정 알림 (시간 설정)**
*   **의미:** 절대적인 알림 시각 (Time of Day)
*   **허용 형식:** `HH:MM` 또는 `HHMM` (예: `19:30`, `1930`). **초(second) 입력은 허용되지 않습니다.**
