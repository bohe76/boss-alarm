# 리팩토링 제안서 (Refactoring Proposal)

본 문서는 현재 "보스 알리미" 애플리케이션의 코드 베이스를 분석하고, 장기적인 유지보수성, 확장성, 안정성을 향상시키기 위한 4가지 주요 리팩토링 방향을 제안합니다.

---

## 제안 1: 중앙 라우팅 및 화면 초기화 매커니즘 도입

*   **현황 및 문제점:**
    *   현재 `event-handlers.js`의 `showScreen` 함수가 `if/else` 분기문을 통해 모든 화면 전환 로직을 처리하고 있습니다. 새로운 화면이 추가될 때마다 이 함수를 직접 수정해야 하므로 **개방-폐쇄 원칙(OCP)**에 위배됩니다.
    *   화면 초기화 방식이 일관되지 않습니다. 어떤 화면은 앱 시작 시 즉시 초기화되고, 다른 화면은 `showScreen` 함수 내에서 지연 초기화되어 구조의 복잡성을 높이고 있습니다.

*   **리팩토링 제안:**
    1.  **라우터(Router) 모듈(`router.js`) 도입:** 화면 ID를 키로, 해당 화면의 초기화(`init`) 및 렌더링(`render`) 함수를 값으로 가지는 '라우팅 테이블' 객체를 중앙에서 관리합니다.
    2.  **`showScreen` 함수 일반화:** `showScreen` 함수는 더 이상 개별 화면의 존재를 알 필요 없이, 라우팅 테이블에서 요청된 화면 정보를 찾아 해당하는 함수를 호출하는 역할만 수행합니다.
    3.  **기대 효과:** 화면 추가 및 제거가 라우팅 테이블 수정만으로 가능해져 유지보수성이 향상되며, 모든 화면의 초기화 및 렌더링 방식이 일관성을 갖게 됩니다.
    4.  **동적 콘텐츠 즉시 렌더링 강조:** 대시보드와 같이 동적으로 변경되는 콘텐츠(예: 남은 시간 카운트다운)를 포함하는 화면의 경우, 화면 활성화 시 초기 렌더링이 즉시 이루어지도록 명시적으로 `renderDashboard(DOM)`와 같은 함수를 호출해야 합니다. 주기적인 `setInterval`만으로는 초기 화면 표시 지연이 발생할 수 있습니다.

---

## 제안 2: `event-handlers.js` 역할 축소 및 `initApp` 함수 분해

*   **현황 및 문제점:**
    *   `initApp` 함수가 서비스 초기화, 데이터 로딩, URL 파싱, 이벤트 핸들러 등록 등 너무 많은 책임을 가지고 있어 가독성이 떨어지고 단일 책임 원칙(SRP)을 위반합니다.
    *   `initEventHandlers` 함수 또한 여러 핵심 화면의 초기화 로직을 동시에 담당하고 있어 역할이 과도합니다.

*   **리팩토링 제안:**
    1.  **`initApp` 함수 분해:** `initApp` 내부 로직을 `initializeCoreServices()`, `parseUrlParameters()`, `setupGlobalEventListeners()`, `initializeScreenHandlers()` 등과 같이 책임에 따라 더 작은 함수로 분해합니다.
    2.  `initApp`은 이렇게 분해된 함수들을 순서대로 호출하는 오케스트레이터 역할만 담당하도록 변경합니다.
    3.  **기대 효과:** 각 초기화 단계의 책임이 명확해지고, 코드의 가독성과 구조적 명확성이 크게 향상됩니다.

---

## 제안 3: 반응형 상태 관리(Reactive State Management) 패턴 도입

*   **현황 및 문제점:**
    *   `BossDataManager`와 같은 상태 관리 객체의 데이터가 변경되어도 UI가 자동으로 갱신되지 않습니다. 상태 변경 후, `EventBus` 이벤트를 발생시키거나 렌더링 함수를 수동으로 호출해야만 UI가 업데이트됩니다.
    *   이러한 명령형 방식은 개발자가 UI 업데이트 호출을 누락할 경우, 데이터와 화면이 불일치하는 버그를 유발할 가능성이 높습니다.

*   **리팩토링 제안:**
    1.  **Observer 패턴 도입:** `BossDataManager`와 같은 상태 관리 객체에 `subscribe(callback)` 메소드를 추가합니다.
    2.  UI 렌더링을 담당하는 모듈(또는 각 화면 모듈)이 `subscribe`를 통해 데이터 변경을 '구독'합니다.
    3.  상태 변경 함수(예: `setBossSchedule`)는 데이터 변경 후, 등록된 모든 콜백(UI 렌더링 함수)을 자동으로 호출하도록 수정합니다.
    4.  **기대 효과:** "데이터가 변경되면 UI는 자동으로 반응한다"는 선언적(declarative) 패턴으로 전환되어, 코드의 안정성과 예측 가능성이 향상됩니다.
    5.  **명시적 임포트:** `BossDataManager`와 같은 상태 관리 객체의 `subscribe` 메소드를 사용하는 모듈에서는 해당 객체를 명시적으로 임포트(`import { BossDataManager } from './data-managers.js';`)해야 합니다.

---

## 제안 4: 렌더링 로직의 완전한 분리 및 응집도 향상

*   **현황 및 문제점:**
    *   대부분의 렌더링 로직은 `ui-renderer.js`에 있으나, `help.js`, `version-info.js` 등 일부 화면 모듈이 여전히 자체적으로 복잡한 HTML 문자열을 생성하는 로직을 가지고 있습니다. 이는 관심사 분리 원칙에 완전히 부합하지 않습니다.

*   **리팩토링 제안:**
    1.  **렌더링 로직 완전 이전:** 모든 종류의 DOM 생성 및 HTML 문자열 구성 로직을 `ui-renderer.js`로 완전히 이전합니다.
    2.  화면 모듈(`help.js` 등)은 데이터(JSON 등)를 가져오는 역할만 수행하고, 그 데이터를 `ui-renderer.js`의 렌더링 함수(예: `renderHelpScreen(DOM, helpData)`)에 인자로 전달하는 책임만 집니다.
    3.  **기대 효과:** 화면 모듈은 '어떻게 그릴 것인가'가 아닌 '무엇을 보여줄 것인가'에만 집중하게 되고, `ui-renderer.js`는 애플리케이션의 모든 시각적 표현을 담당하는 단일 모듈로서 응집도가 극대화됩니다.